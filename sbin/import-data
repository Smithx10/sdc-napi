#!/opt/smartdc/napi/node/bin/node

/*
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 *
 * Bulk importing data into moray's NAPI tables
 */

var bunyan = require('bunyan');
var fs = require('fs');
var mod_config = require('../lib/config');
var moray = require('moray');
var napi = require('sdc-clients').NAPI;
var nopt = require('nopt');
var path = require('path');
var util = require('util');
var util_ip = require('../lib/util/ip');
var vasync = require('vasync');
var VError = require('verror').VError;



var CONFIG;
var DIRECTORY;
var DRY_RUN = false;
var FILES;
var NAPI;
var NETWORKS = {};
var NETWORK_MAP = {};
var NIC_TAGS = {};
var OLD_NETWORKS = [];


// --- Utilities



function enter(str) {
    console.log('');
    console.log('== %s', str);
    console.log('');
}


function readAllLines(file, callback) {
    return fs.readFile(file, 'utf8', function (err, data) {
        if (err) {
            return callback(err);
        }

        return callback(null, data.split('\n'));
    });
}


function readLines(file, dataCallback, doneCallback) {
    var leftover = '';
    var rs = fs.createReadStream(file, { flags: 'r', encoding: 'utf8' });

    rs.on('data', function (data) {
        var pieces = (leftover + data.toString()).split(/\n/g);
        leftover = pieces.pop();

        return dataCallback(pieces);
    });

    rs.on('end', function () {
        if (leftover.length !== 0) {
            dataCallback(leftover);
        }
        return doneCallback();
    });
}


function usage(msg, code) {
    if (typeof (msg) === 'string') {
        console.error(msg);
    }

    console.error('%s <directory>', path.basename(process.argv[1]));
    process.exit(code || 0);
}


function process_argv() {
    var dir;
    var longOpts = {
        'dryrun': Boolean
    };
    var parsed = nopt(longOpts);

    if (parsed.dryrun) {
        DRY_RUN = true;
        console.log('dry run: not modifying any data');
    }

    if (parsed.argv.remain.length < 1) {
        usage(null, 1);
    }
    dir = parsed.argv.remain[0];

    try {
        var stats = fs.statSync(dir);
        if (!stats.isDirectory()) {
            usage(dir + ' is not a directory', 1);
        }
    } catch (e) {
        usage(dir + ' is invalid: ' + e.message, 1);
    }

    DIRECTORY = dir;
}

function morayClient(callback) {
    var log = bunyan.createLogger({
        name: path.basename(process.argv[1]),
        level: (process.env.LOG_LEVEL || 'info'),
        stream: process.stderr,
        serializers: bunyan.stdSerializers
    });

    var conf = {
        connectTimeout: 10000,
        log: log,
        host: CONFIG.moray.host,
        noCache: true,
        port: CONFIG.moray.port,
        retry: {
            retries: Infinity,
            minTimeout: 1000,
            maxTimeout: 60000
        }
    };
    var client = moray.createClient(conf);

    function onMorayError(err) {
        return callback(err);
    }

    function onMorayConnect() {
        client.removeListener('error', onMorayError);
        client.on('close', function () {
            client.log.error('moray: closed');
        });

        client.on('connect', function () {
            client.log.info('moray: reconnected');
        });

        client.on('error', function (err) {
            client.log.warn(err, 'moray: error (reconnecting)');
        });

        return callback(null, client);
    }

    client.once('connect', onMorayConnect);
    client.once('error', onMorayError);
}


function subnetEndIP(start, bits) {
    var startNum = Number(start);
    var bitsNum = Number(bits);
    if (!startNum || !bitsNum) {
        return null;
    }
    return startNum + Math.pow(2, 32 - bitsNum) - 1;
}


// --- Main functions



function getFiles(_, callback) {
    fs.readdir(DIRECTORY, function (err, res) {
        if (err) {
            usage(err.message, 1);
        }

        FILES = res;
        callback();
    });
}


function getNicTags(_, callback) {
    enter('getting existing nic tags');
    NAPI.listNicTags(function (err, res) {
        if (res) {
            console.log('found nic tags:');
            res.forEach(function (t) {
                console.log('* %s: %s', t.uuid, t.name);
                NIC_TAGS[t.name] = t.uuid;
            });
        }

        return callback(err);
    });
}


function getNetworks(_, callback) {
    enter('getting existing networks');
    NAPI.listNetworks(function (err, res) {
        if (res) {
            console.log('found networks:');
            res.forEach(function (n) {
                console.log('* %s: name=%s, nic_tag=%s, subnet=%s, vlan_id=%d',
                    n.uuid, n.name, n.nic_tag, n.subnet, n.vlan_id);
                OLD_NETWORKS.push(n);
            });
        }

        return callback(err);
    });
}


function createNicTags(_, callback) {
    enter('creating nic tags');
    readAllLines(DIRECTORY + '/napi_nic_tags.moray', function (err, lines) {
        if (err) {
            return callback(err);
        }

        vasync.forEachParallel({
            inputs: lines,
            func: function _create(line, cb) {
                if (line === '') {
                    return cb();
                }

                try {
                    var json = JSON.parse(line);
                } catch (err2) {
                    return cb(err2);
                }

                if (NIC_TAGS.hasOwnProperty(json.name)) {
                    console.log('nic tag %s already exists: not creating',
                        json.name);
                    return cb();
                }

                if (DRY_RUN) {
                    console.log('created nic tag %s', json.name);
                    return cb();
                }

                NAPI.createNicTag(json.name, json, function (err3, res) {
                    if (res) {
                        console.log('created nic tag %s', json.name);
                    }

                    return cb(err3);
                });
            }
        }, callback);
    });
}


function createNetworks(_, callback) {
    enter('creating networks');
    readAllLines(DIRECTORY + '/napi_networks.moray', function (err, lines) {
        if (err) {
            return callback(err);
        }

        vasync.forEachParallel({
            inputs: lines,
            func: function _create(line, cb) {
                if (line === '') {
                    return cb();
                }

                try {
                    var json = JSON.parse(line);
                } catch (err2) {
                    return cb(err2);
                }

                // Before we fix change numbers into IP addresses, look for
                // networks with bad provision_end_ips
                if (json.hasOwnProperty('provision_end_ip') &&
                    json.hasOwnProperty('subnet_start_ip') &&
                    json.hasOwnProperty('subnet_bits')) {
                    var broadcast = subnetEndIP(json.subnet_start_ip,
                        json.subnet_bits);
                    if (!broadcast) {
                        return cb(new VError(
                            'Network "%s" has invalid subnet "%s/%s"',
                            json.uuid, json.subnet_start_ip,
                            json.subnet_bits));
                    }

                    console.log('UUID: %s, end=%s, broad=%s',
                            json.uuid, json.provision_end_ip, broadcast);
                    if (Number(broadcast) == Number(json.provision_end_ip)) {
                        var oldEnd = util_ip.ntoa(broadcast);
                        var newEnd = util_ip.ntoa(broadcast - 1);
                        console.log('Network "%s": provision_end_ip "%s" is '
                            + 'the broadcast address: setting to "%s"',
                            json.uuid, oldEnd, newEnd);
                        json.provision_end_ip = broadcast - 1;
                    }
                }

                ['gateway', 'provision_start_ip', 'provision_end_ip',
                    'subnet_start_ip'].forEach(
                    function (p) {
                    if (json.hasOwnProperty(p)) {
                        json[p] = util_ip.ntoa(json[p]);
                    }
                });

                if (json.hasOwnProperty('resolvers')) {
                    json.resolvers = json.resolvers.map(function (r) {
                        return util_ip.ntoa(r);
                    });
                }

                json.subnet = util.format('%s/%s', json.subnet_start_ip,
                        json.subnet_bits);

                for (var n in OLD_NETWORKS) {
                    var oldNet = OLD_NETWORKS[n];
                    if (json.subnet == oldNet.subnet &&
                        json.nic_tag == oldNet.nic_tag &&
                        json.vlan_id == oldNet.vlan_id) {
                        console.log(
                            'network "%s" matches existing network "%s": ' +
                            'not creating: %s', json.name, oldNet.name,
                            JSON.stringify(json, null, 2));
                        NETWORK_MAP[json.uuid] = oldNet.uuid;
                        NETWORKS[oldNet.uuid] = oldNet;
                        return cb();
                    }
                }

                if (DRY_RUN) {
                    console.log('created network %s: %s', json.name,
                        JSON.stringify(json, null, 2));
                    NETWORKS[json.uuid] = json;
                    return cb();
                }

                NAPI.createNetwork(json, function (err3, res) {
                    if (res) {
                        console.log('created network %s: %s', json.name,
                            JSON.stringify(res, null, 2));
                        NETWORKS[res.uuid] = res;
                    }

                    return cb(err3);
                });
            }
        }, callback);
    });
}


function createNetworkPools(_, callback) {
    enter('creating network pools');
    readAllLines(DIRECTORY + '/napi_network_pools.moray',
        function (err, lines) {
        if (err) {
            // The original install may not have had any network pools, so this
            // file might not exist
            if (err.code === 'ENOENT') {
                console.log('no network pools to create');
                return callback();
            }
            return callback(err);
        }

        vasync.forEachParallel({
            inputs: lines,
            func: function _create(line, cb) {
                if (line === '') {
                    return cb();
                }

                try {
                    var json = JSON.parse(line);
                } catch (err2) {
                    return cb(err2);
                }

                if (DRY_RUN) {
                    console.log('created network pool %s: %s', json.name,
                        JSON.stringify(json, null, 2));
                    return cb();
                }

                var nets = [];
                json.networks.forEach(function (network) {
                    if (NETWORK_MAP.hasOwnProperty(network)) {
                        console.log('> network %s is actually existing '
                            + 'network', network,
                            NETWORK_MAP[network]);
                        nets.push(NETWORK_MAP[network]);
                    } else {
                        nets.push(network);
                    }
                });
                json.networks = nets;

                NAPI.createNetworkPool(json.name, json, function (err3, res) {
                    if (res) {
                        console.log('created network pool %s: %s', json.name,
                            JSON.stringify(res, null, 2));
                    }

                    return cb(err3);
                });
            }
        }, callback);
    });
}


function createNetworkIPs(file, cb) {
    var bucketName = path.basename(file, '.moray').replace(/-/g, '_');
    var client;
    var closed = false;
    var finished = 0;
    var network = bucketName.replace('napi_ips_', '').replace(/_/g, '-');

    // Figure out if this network is actually a network that already exists
    // in NAPI
    if (NETWORK_MAP.hasOwnProperty(network)) {
        console.log('> network %s is actually existing network', network,
            NETWORK_MAP[network]);
        network = NETWORK_MAP[network];
        bucketName = 'napi_ips_' + network.replace(/-/g, '_');
    }

    var provEnd = util_ip.aton(NETWORKS[network].provision_end_ip);
    var provStart = util_ip.aton(NETWORKS[network].provision_start_ip);
    var started = 0;

    console.log('> network %s: adding IPs to bucket %s', network, bucketName);

    function _returnIfDone(err) {
        if (!closed || finished !== started) {
            return;
        }

        if (client) {
            client.close();
        }

        console.log('> network %s: adding IPs done', network);
        return cb();
    }

    morayClient(function (err, res) {
        if (err) {
            return cb(err);
        }
        client = res;

        readLines(DIRECTORY + '/' + file, function (lines, stream) {
            var batch = lines.filter(function (line) {
                return line;
            }).map(function (line) {
                var json;
                try {
                    json = JSON.parse(line);
                } catch (err2) {
                    console.error('Error reading line from "%s":', file);
                    console.error(line);
                    throw err2;
                }

                return {
                    bucket : bucketName,
                    key: json.ip,
                    operation: 'put',
                    value: json
                };
            }).filter(function (ip) {
                if (ip.value.hasOwnProperty('belongs_to_uuid') ||
                    ip.value.hasOwnProperty('belongs_to_type') ||
                    ip.value.hasOwnProperty('owner_uuid')) {
                    return true;
                }
                var num = Number(ip.key);

                if (ip.value.reserved && ((num < provStart) ||
                    (num > provEnd))) {
                    return false;
                }

                return true;
            });

            started++;

            console.log('  adding %d IPs to bucket %s',
                batch.length, bucketName);

            if (DRY_RUN) {
                finished++;
                return _returnIfDone();
            }

            vasync.forEachParallel({
                inputs: batch,
                func: function _createIP(rec, cb2) {
                    // console.log('creating IP %s', rec.key);
                    client.putObject(rec.bucket, rec.key, rec.value,
                        { etag: null }, function (err3) {
                        if (err3 && err3.name === 'EtagConflictError') {
                            console.log('  IP %s/%s already exists: ignoring',
                                rec.bucket, rec.key);
                            return cb2();
                        }

                        return cb2(err3);
                   });
                }
            }, function (err2) {
                finished++;

                if (err2) {
                    console.error('Error adding batch to %s: %s', bucketName,
                        err2.toString());
                    stream.destroy();
                }

                _returnIfDone();
            });

        }, function () {
            closed = true;

            _returnIfDone();
        });
    });
}


function createIPs(_, callback) {
    enter('creating IPs');
    var ipFiles = FILES.filter(function (f) { return /^napi_ips/.test(f); });

    vasync.forEachParallel({
        inputs: ipFiles,
        func: createNetworkIPs
    }, callback);
}


function createNics(file, cb) {
    var client;
    var closed = false;
    var finished = 0;
    var started = 0;

    enter('creating nics');

    function _returnIfDone(err) {
        if (!closed || finished !== started) {
            return;
        }

        if (client) {
            client.close();
        }

        console.log('> adding nics done');
        return cb();
    }

    morayClient(function (err, res) {
        if (err) {
            return cb(err);
        }
        client = res;

        readLines(DIRECTORY + '/napi_nics.moray', function (lines, stream) {
            var batch = lines.filter(function (line) {
                return line;
            }).map(function (line) {
                var json = JSON.parse(line);
                if (json.hasOwnProperty('network_uuid') &&
                    NETWORK_MAP.hasOwnProperty(json.network_uuid)) {
                    json.network_uuid = NETWORK_MAP[json.network_uuid];
                }

                return {
                    bucket : 'napi_nics',
                    key: json.mac.toString(),
                    operation: 'put',
                    value: json
                };
            });

            started++;

            console.log('  adding %d nics to bucket napi_nics', batch.length);

            if (DRY_RUN) {
                finished++;
                return _returnIfDone();
            }

            vasync.forEachParallel({
                inputs: batch,
                func: function _createNic(rec, cb2) {
                    // console.log('creating nic %s', rec.key);
                    client.putObject(rec.bucket, rec.key, rec.value,
                        { etag: null }, function (err3) {
                        if (err3 && err3.name === 'EtagConflictError') {
                            // Already exists - ignore
                            console.log('  nic %s already exists: ignoring',
                                rec.key);
                            return cb2();
                        }

                        return cb2(err3);
                   });
                }
            }, function (err2) {
                finished++;

                if (err2) {
                    console.error('Error creating nic: %s', err2.toString());
                    stream.destroy();
                }

                _returnIfDone();
            });
        }, function () {
            closed = true;

            _returnIfDone();
        });
    });
}


function main() {
    process_argv();

    CONFIG = mod_config.load(
        path.normalize(__dirname + '/../config.json'));
    NAPI = new napi({
        url: 'http://localhost:' + CONFIG.port
    });

    vasync.pipeline({
    funcs: [
        getFiles,
        getNicTags,
        getNetworks,
        createNicTags,
        createNetworks,
        createNetworkPools,
        createIPs,
        createNics

    ] }, function (err) {
        enter('done');

        if (err) {
            console.error(err.message);
            if (err.hasOwnProperty('ase_errors')) {
                err.ase_errors.forEach(function (e) {
                    if (e.hasOwnProperty('body')) {
                        console.error(JSON.stringify(e.body, null, 2));
                    } else {
                        console.error(e.message);
                    }
                });
            }
        }

        if (NAPI) {
            NAPI.client.close();
        }

        if (err) {
            process.exit(1);
        }
    });
}

main();
